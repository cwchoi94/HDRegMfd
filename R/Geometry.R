#' Basic geometry structure on manifolds
#' 
#' Basic:
#' inner product, norm in tangent spaces, distance
#' exponential and logarithmic maps
#' 
#' For PCA:
#' Frechet mean, PCA
#' 


#' Check whether manifolds or not
#' 
#' @param space a name of space, one of 'Euclid', 'simplex', 'sphere', 'SPD.LogEuclid', 'SPD.AffInv', 'functional', 'BayesHilbert', or 'Wasserstein'.
#' 
#' @export
Check.manifold = function(space){
  if (!(space %in% c('Euclid','simplex','sphere','SPD.LogEuclid','SPD.AffInv','functional','BayesHilbert','Wasserstein'))){
    stop("The space should be one of 'Euclid', 'simplex', 'sphere', 'SPD.LogEuclid', 'SPD.AffInv', 'functional', 'BayesHilbert', or 'Wasserstein'.")
  }
}


#' Inner product on the tangent space at \eqn{p}
#' 
#' @inheritParams Check.manifold
#' 
#' @param u,v \eqn{n\times m'} Matrices. Each row is tangent vector.
#' @param p an \eqn{m} vector of the base point on tangent space
#' 
#' @return an \eqn{n} vector of inner products of each row of u and v
#' @export
inner.manifold = function(u,v,p,space='Euclid'){
  Check.manifold(space)
  inner = eval(parse(text=paste0('inner.',space)))
  z = inner(u,v,p)
  return(z)
}


#' norm on the tangent space at \eqn{p}
#' 
#' @inheritParams Check.manifold
#' 
#' @param u a \eqn{n\times m'} matrix. Each row is a tangent vector.
#' @param p an \eqn{m} vector of the base point on tangent space
#' 
#' @return an \eqn{n} vector of norm. Each entry is the norm of \eqn{u_i} at p
#' @export
norm.manifold = function(u,p,space='Euclid'){
  Check.manifold(space)
  norm = eval(parse(text=paste0('norm.',space)))
  z = norm(u,p)
  return(z)
}



#' Geodesic distance on the manfold
#' 
#' @param p,q \eqn{m} vectors or \eqn{n\times m} matrices. Each row is a point on the Riemannian metric spaces.
#' 
#' @inheritParams Check.manifold
#' 
#' @return an \eqn{n} vector of geodesic distance. Each entry is a distance between \eqn{p_i} and \eqn{q_i}.
#' @export
dist.manifold = function(p,q,space='Euclid'){
  Check.manifold(space)
  dist = eval(parse(text=paste0('dist.',space)))
  z = dist(p,q)
  return(z)
}


#' Riemannian exponential map
#' 
#' @inheritParams Check.manifold
#' 
#' @param p an \eqn{m} vector of the base point on tangent space
#' @param u an \eqn{n\times m'} matrix. Each row is a tangent vector.
#' 
#' @return an \eqn{n\times m} matrix. Each row is a point on the Riemannian metric spaces.
#' @export
RieExp.manifold = function(p,u,space='Euclid'){
  Check.manifold(space)
  RieExp = eval(parse(text=paste0('RieExp.',space)))
  z = RieExp(p,u)
  return(z)
}


#' Riemannian logarithmic map
#' 
#' @inheritParams Check.manifold
#' 
#' @param p,q \eqn{m} vectors or \eqn{n\times m} matrices. Each row is a point on the manifold.
#' 
#' @return an \eqn{n\times m} matrix. Each row is a logarithmic map from \eqn{p_i} to \eqn{q_i}.
#' @export
RieLog.manifold = function(p,q,space='Euclid'){
  Check.manifold(space)
  RieLog = eval(parse(text=paste0('RieLog.',space)))
  z = RieLog(p,q)
  return(z)
}


#' Basis on the tangent space at p
#' 
#' @inheritParams Check.manifold
#' 
#' @param p an \eqn{m} vector of the point on Riemannian metric spaces.
#' @param dim a number of basis, only used for infinite-dimensional Riemannian metric spaces.
#' 
#' @return an \eqn{n\times m} matrix. Each row is an orthonormal basis of the tangent space at p.
#' @export
basis.manifold = function(p,dim=50,space='Euclid'){
  Check.manifold(space)
  basis = eval(parse(text=paste0('basis.',space)))
  z = basis(p,dim)
  return(z)
}


#' Frechet mean on the manifold
#' 
#' @param X a \eqn{n\times m} matrix. Each row is a point on the Riemannian metric spaces.
#' 
#' @inheritParams Check.manifold
#' 
#' @return an \eqn{m} vector
#' @export
FrechetMean.manifold = function(X,space='Euclid'){
  Check.manifold(space)
  FrechetMean = eval(parse(text=paste0('FrechetMean.',space)))
  z = FrechetMean(X)
  return(z)
}


#' Principal component analysis for manifold-valued data.
#' 
#' @inheritParams FrechetMean
#' @param alpha a truncation parameter of the number of vectors, only used for infinite dimensional manifolds. Select the first index where the sum of the variances is equal to or greater than the alpha of the total.
#' 
#' @return a 'PCA.manifold' object
#' \describe{
#'       \item{space}{a name of the underlying space.}
#'       \item{values}{an \eqn{m} vector of eigenvalues.}
#'       \item{vectors}{a \eqn{K\times m} matrix. Each row is an orthornormal basis generated by PCA.}
#'       \item{mu}{the Frechet mean of X, \eqn{m} vector.}
#'       \item{dim}{a number of eigenvectors \eqn{K}}
#'       \item{...}{Passed into specific method}
#' }
#' @export
PCA.manifold = function(X,space='Euclid',alpha=0.95){
  Check.manifold(space)
  PCA = eval(parse(text=paste0('PCA.',space)))
  z = PCA(X,alpha)
  z[['space']] = space
  class(z) = 'PCA.manifold'
  return(z)
}


#' Prediction score matrix of manifold-valued data.
#' 
#' @param object a \code{\link{PCA.manifold}} object.
#' @param Xnew an \eqn{n\times m} matrix). Each row is a point on the space.
#' 
#' @return an \eqn{n\times m'} score matrix.
#' @export
predict.PCA.manifold = function(object,Xnew){
  n2 = nrow(Xnew)
  
  space = object[['space']]
  dim = object[['dim']]
  mu = object[['mu']]
  vectors = object[['vectors']]
  
  Xnew.tangent = RieLog.manifold(mu,Xnew,space)
  scores = sapply(1:dim,function(j){inner.manifold(Xnew.tangent,vectors[j,],mu,space)})
  return (scores)
}



